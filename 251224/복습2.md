# 오늘 배운 것 핵심 복습 (머리 고정용)

## 값 타입 vs 참조 타입 (네가 제일 헷갈린 핵심)
구분 | 값 타입 (struct, int 등) | 참조 타입 (class, 배열 등)
|---|---|---|
복사하면 | 값이 복사됨 | 같은 객체를 같이 봄
저장 위치 | 보통 스택 | 힙
함수에 넘기면 | 새로운 값이 전달됨 | 주소(참조)가 전달됨

> 네가 헷갈린 이유:  
> “원본이 바뀐다” vs “같은 객체를 본다”  
> → 사실 둘 다 맞다.  
> 같은 객체를 보니까 원본 값이 실제로 바뀌는 것이다.

## 배열 전달 문제 2번 vs 3번

### 문제 2
```csharp
arr[0] = 99;
```
👉 같은 배열을 보고 있으므로 원본 변경됨

### 문제 3
```csharp
arr = new int[] { 9,9,9 };
```
👉 arr이라는 지역 참조만 바뀌고 원본은 안 바뀜

> 헷갈린 이유:  
> 배열은 참조 타입이지만  
> 참조 변수 자체는 값 타입처럼 복사됨.

## new의 진짜 의미
> 힙에 객체를 만들고, 그 주소를 받는다
- `new Player()` → Player 객체 생성
- 변수에는 객체 자체가 아니라 주소만 들어 있음

## static이 공유되는 이유
> static은 “인스턴스마다”가 아니라  
> 클래스 자체에 딱 하나만 존재하는 데이터다.

그래서:
- 인스턴스를 10개 만들어도
- static 변수는 딱 하나, 같은 주소 하나다.

## 제네릭이 왜 필요한지
> object 기반 구조 → 박싱/언박싱 발생 → 느림 + 위험  
> 제네릭 → 타입 그대로 사용 → 빠르고 안전

👉 그래서 List<int>, Container<T> 같은 구조가 생겼다.

## 인터페이스 = “약속”
> “이 클래스는 이 기능을 반드시 갖는다”라는 보증서
- 기능 누락 방지
- 역할 중심 설계
- 다형성 가능

## 델리게이트 & 이벤트 = 알림 시스템
> “무슨 일이 일어났을 때  
> 누가 반응할지 몰라도 그냥 알려주기”
- Player → 체력 변함
- UI, 사운드 → 자동으로 반응

# 한 줄 요약
네가 느낀 혼란 | 실제 정체
|---|---|
new 뭐지? | 힙에 객체 만들고 주소 받는 것
배열 왜 바뀜? | 같은 객체를 같이 보기 때문
static 왜 공유됨? | 클래스에 딱 하나만 존재
제네릭 왜 쓰나? | 박싱 없애고 빠르게 쓰려고
이벤트 왜 쓰나? | 객체끼리 느슨하게 소통하려고