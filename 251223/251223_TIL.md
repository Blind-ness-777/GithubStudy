# TIL - C# 객체지향 기초 (Static / 상속 / 다형성 / 타입 캐스팅)

## 오늘의 학습 요약
오늘은 C# 객체지향 프로그래밍의 핵심 개념인 `static`, 상속, 오버로딩/오버라이딩, 타입 캐스팅(is / as), 추상 클래스에 대해 학습했다.  
절차지향 방식과 비교했을 때 객체지향은 코드가 많아질 수 있지만, 유지보수성과 확장성을 위해 필요한 구조라는 점을 이해했다.
<br></br>

## Static 키워드

### Static 개념
- `static`으로 선언된 변수와 메서드는 **클래스 단위로 하나만 존재**한다.
- 인스턴스를 여러 개 생성해도 **모두 같은 static 데이터를 공유**한다.
- 프로그램 실행 시 초기화되며, **프로그램 종료 시까지 메모리에 상주**한다.

### Static 특징
- 인스턴스를 생성하지 않고 `클래스명.멤버` 형태로 접근 가능
- static 생성자는 **한 번만 호출**된다.
- static 멤버는 static 멤버만 직접 접근 가능
- 남용 시 전역 상태가 되어 유지보수가 어려워질 수 있음

```csharp
public class StaticStudy
{
    public static int value = 15;
}

Console.WriteLine(StaticStudy.value);
```
### 참조 타입과 메모리
- 클래스와 배열은 참조 타입으로 힙 메모리에 저장된다.
- GC(Garbage Collector)에 의해 실행 중 실제 메모리 주소가 이동할 수 있다.
- 개발자는 객체의 실제 메모리 주소를 직접 알거나 통제할 수 없다.
<br></br>

## 상속 (Inheritance)

### 상속 개념
- 공통 필드와 메서드를 부모 클래스에 정의하고 자식 클래스에서 재사용
- 코드 중복을 줄이고 유지보수성을 향상시킨다.
```csharp
public class Monster
{
    public string Name;
    public int AttackValue = 10;

    public void Attack()
    {
        Console.WriteLine($"{Name} 공격");
    }
}

public class Goblin : Monster
{
    public Goblin()
    {
        Name = "Goblin";
    }
}
```

### 생성자와 상속
- 자식 클래스 생성 시 부모 생성자가 먼저 호출된다.
- `base()`를 사용해 부모 생성자를 명시적으로 호출 가능
```csharp
public Goblin(string name) : base(name)
{
    AttackValue = 15;
}
```

### 오버로딩 (Overloading)
- 같은 메서드 이름, 다른 매개변수
- 컴파일 타임에 결정됨
```csharp
public void Attack()
{
}

public void Attack(int damage)
{
}
```

### 오버라이딩 (Overriding)
- 부모 클래스의 `virtual` 메서드를 자식 클래스에서 재정의
- 런타임에 실제 객체 타입 기준으로 호출됨
```csharp
public virtual void Skill()
{
}

public override void Skill()
{
}
```
<br></br>

## 타입 캐스팅 (is / as)

### 업캐스팅
- 자식 객체 → 부모 타입
- 항상 가능
```csharp
Monster mon = new Goblin("Goblin");
```

### 다운캐스팅
- 부모 타입 → 자식 타입
- 실제 객체 타입에 따라 성공/실패
```csharp
if (mon is Goblin)
{
    Goblin g = mon as Goblin;
}
```
- `is` : 타입 검사 (bool 반환)
- `as` : 형변환 시도, 실패하면 null 반환
- 객체의 실제 타입은 new로 생성한 타입 기준
<br></br>

## 추상 클래스 (Abstract)

### 추상 클래스 특징
- 인스턴스 생성 불가
- 상속을 위한 뼈대 역할
- 추상 메서드는 구현 없이 선언만 함
```csharp
public abstract class Monster
{
    public abstract void Skill();
}
```
<br></br>

## 느낀 점

오늘 배운 내용은 한 번에 이해하기 어려웠지만,
객체지향은 규모가 커질수록 유지보수와 협업을 위해 반드시 필요한 구조라는 점을 느꼈다.
완벽한 이해보다는 개념을 반복해서 익히는 것이 중요하다고 생각한다.