TIL (Today I Learned) – 자료구조 해시테이블(Dictionary<T>), 비선형 자료구조 그래프, 트리

**날짜: 2025.12.30 화요일**

# 자료구조 - 해시테이블
- 해시테이블은 `Key`와 `Value`을 한 쌍으로 저장하는 자료구조. `Key`를 기준으로 값을 저장.
- 데이터 입력 시 `Key`는 `해싱(Hashing)`되어 값을 가리키는 고유한 식별자 역활
- **평균적으로** 삽입, 삭제, 읽기, 검색이 `O(1)`, 충돌이 심할 경우 `O(n)`
- `Hash` : 임의의 길이를 가진 데이터를 `해시 알고리즘`을 사용해 고정된 길이를 가진 데이터로 출력한 값
    - 단방향성 : 데이터를 해시 값으로 출력 가능. 해시 값을 원래 키 데이터로 돌리는 것 불가
    - 해시 충돌 최소화 : 해시는 고유한 식별자. 저장된 데이터의 지문과 같은 역활
    - 어떤 데이터를 삽입하든 해싱의 결과물은 항상 고정된 데이터의 길이를 가진다
    - `Key` : 
        - 데이터를 저장하고 찾기 위해 사용되는 고유한 식별자.
        - 해시 함수를 거쳐 데이터를 보관할 수 있는 식별코드(해시코드)로 전환. 해시 테이블에서는 이 `Key`만 해싱이 적용
    - `Value` :
        - 해싱 된 `Key`를 기반으로 자료 구조에 저장하는 테이터
    - `해시 함수` :
        - 입력 데이터를 해시 코드로 출력해주는 함수
        - 해시 함수의 성능이 해시 테이블의 전반적인 성능을 결정

- 키 충돌 **(기술 면접 나올 가능성 있음)★**
    - `체이닝(Chaining)` : 배열의 원소를 연결리스트로 구현해서 같은 키 값을 가지는 데이터를 보관
    - `개방 주소법(Open Addressing) : 선형 탐사(Linear Probing)` : 배열을 지정된 폭만큼 순회하며 빈 공간에 할당
    - `개방 주소법(Open Addressing) : 제곱 탐사(Quadractic Probing)` : 충돌이 발생 시 첫번째는 1², 두번째는 2², 세번째는 3²으로 n²순으로 폭을 늘려가면서 인덱스를 탐색하고 데이터를 보관
    - `개방 주소법(Open Addressing) : 이중 해싱(Double Hashing Probing)` : 충돌된 해시 값을 한 번 더 해싱한다. 충돌이 일어나지 않을 때까지 반복하고 다른 인덱스에 할당
    <br></br>

## 학습 목표
- 해시 테이블의 동작 원리
- `Dictionary<T>`의 사용법

## 제네릭 컬렉션 - Dictionary<T>
- `Dictionary<T>`는 이름 그대로 `사전`에서 필요한 정보를 찾는 과정을 통해 저장된 데이터를 찾을 수 있다
- 런타임에 `Key`를 통해 빠르게 **추가·검색·수정할 수 있는 자료구조**
```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.Clear();

        Dictionary<string, int> dict = new();
        
        dict.Add("이승열", 59);
        dict.Add("이인", 19);

        dict.TryAdd("이인", 59);
        // TryAdd로 굳이 같은 키 값을 지닌 것을 추가하는 것 권장하지 않음

        dict["최원탁"] = 12;

        Console.WriteLine(dict["최원탁"]);

        if (!dict.ContainsKey("송근형"))
        {
            dict.Add("송근형", 92);
        }
        else
        {
            // 추가할 수 없었을 때의 처리
        }

        // dict.Remove("이인");

        Console.WriteLine(dict["이인"]);

        foreach (KeyValuePair<string, int> item in dict)
        {
            Console.WriteLine($"key = {item.Key}, value = {item.Value}");
        }

        Console.WriteLine(dict.Count);
        
        
        // 키 값을 int로 할 경우는 List가 더 어울린다. 단, 목적성이 어울리면 사용해도 되나 이 자료구조를 왜 사용했는지 설명하면 된다.
        Dictionary<int, Item> monsters = new();
        List<Item> list = new();
    }
}

public class Item
{
}
```

- **`HashSet<T>`★** : 중복된 자료가 있는지 검색할 때 유용하다. 내부적으로 해시테이블 기반으로 동작한다. 중복을 허용하지 않는 집합(Set) 자료구조.
<br></br>

# 그래프
- 데이터의 구조는 단순히 일직선상으로만 표현할 수 없다. 게임에서 구현되는 그물형 스킬트리 구조 혹은 우리 일상생활에서 사람과 사람사이의 관계도 등 데이터와 데이터의 관계도를 표현하는 자료구조

## 학습 목표
- 비선형 자료구조의 종류
- 그래프와 트리의 차이점
- 그래프의 구조 이해와 구현

### 비선형 자료구조
- 데이터 간의 관계도 혹은 계층을 표현하기 위한 자료구조
- 대표적으로 그래프와 트리가 있으며 조건에 따라 여러 종류로 나뉨

#### 그래프
- 데이터 간의 다양한 연결 관계를 표현
- 정점(Vertex, Node)과 이들을 연결하는 간선(Edge)로 구성
- 간선에는 가중치(부여할 수 있는 수치) 혹은 방향이 포함될 수 있다
- 반드시 모든 정점이 간선으로 연결되어야 하는 것은 아니다

#### 트리
- 데이터 간의 계층 구조를 정의하는 자료구조
- 각 노드는 `하나`의 부모 노드를 가진다. 시작점이 되는 노드 : `루트노드(Root Node)`,  
가장 하위에 있어 자식 노드가 없는 노드를 `리프노드(Leaf Node)`
- 루트 노트에서 시작해 리프 노드로 이어진다
- 모든 노드가 전부 연결되어 있다
- C# 제네릭 컬렉션 > SortedSet<T>
- `SortedSet<T>`와 같은 트리 기반 컬렉션은 자동 정렬된 구조를 유지한다.

#### 차이점
| 그래프(Graph) |   | 트리(Tree) |
|---|---|---|
| 비계층적 | 구조 | 계층적 |
| 다양한 방향 표현 가능 | 방향 | 부모 -> 자식 단방향 |
| 허용됨 | 사이클 | 없음 |
| 비연결 노드 표현 가능 | 연결성 | 항상 연결된 구조 |
| 제한 없음 | 간선의 수 | 노드 수 - 1 |
| 두 노드 간 다수 경로 가능 | 경로 | 두 노드 간 하나의 경로만 존재 |

#### 그래프 탐색
- 추후에 다시 배울 것
    - BFS(Breadth First Search) : 넓게 탐색 진행
    - DFS(Depth First Search) : 깊게 탐색 진행

## 느낀 점
`List<T>`와 함께 가장 많이 쓰이는 `Dictionary<T>`는 같은 선형 자료구조를 가지고 있어 이해하는데 크게 어려움을 없었다.  
`Graph`와 `Tree`는 문법적 이해가 선형 자료구조를 배워서 인지 크게 어려움은 없었으나, 그래프 탐색 방법 등 선형 자료구조와는 다른 점이 많아 더 많이 공부해야 할 것 같다.