# 과제 1. 객체지향 학습내용 블로그 작성
- `[객체지향 프로그래밍 & 값 / 참조 타입]`
  - https://velog.io/@wlsgod10/TIL-Today-I-Learned-C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%92-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85
---
- `[구조체와 클래스]`
  - https://velog.io/@wlsgod10/TIL-Today-I-Learned-C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%92-%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85-wcqf0z6x
---
- `[객체지향 기초 (Static / 상속 / 다형성 / 타입 캐스팅)]`
  - https://velog.io/@wlsgod10/TIL-C-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EA%B8%B0%EC%B4%88-Static-%EC%83%81%EC%86%8D-%EB%8B%A4%ED%98%95%EC%84%B1-%ED%83%80%EC%9E%85-%EC%BA%90%EC%8A%A4%ED%8C%85
---
- `[Generic / Interface / Delegate & Event]`
  - https://velog.io/@wlsgod10/TIL-Today-I-Learned-Generic-Interface-Delegate-Event
---
- `[확장 메서드 / Nullable / C# 기타 문법 정리]`
  - https://velog.io/@wlsgod10/TIL-%ED%99%95%EC%9E%A5-%EB%A9%94%EC%84%9C%EB%93%9C-Nullable-C-%EA%B8%B0%ED%83%80-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC
---

# 과제 2(심화/선택사항). 인덱서 (Indexer)
- MSDN에 따르면 Property와 유사하다고 합니다. 실제로 get과 set을 가지고 있으며, 작동 방식 또한 같습니다. 단지 `접근자 get과 set을 매개 변수`로 사용합니다.
```csharp
// Property
public int Health
{
    get { return _health; }
    set { _health = value; }
}

// indexer
public int this[int index]
{
    get { return _items[index]; }
    set { _items[index] = value; }
}
```
- Property가 항상 해당 `객체의 하나의 상태`를 의미한다면
- Indexer는 해당 `객체 안의 여러 개 중 하나`를 의미합니다.
- 그래서 쉽게 인덱서는 `배열과 결합된 프로퍼티`라고 생각하면 됩니다.

- 인덱서는 확장 메서드와 같이 `this`를 사용하며, `static` 일 수 없습니다.
- 인덱서는 void형이 될 수 없고, 변수가 아니기에 `ref`, `out`과 함께 인자로 사용될 수 없습니다.
- 또한 정수 인덱스 값이 필요하지 않고, 인덱스 구성 및 조건도 모두 사용자가 지정할 수 있습니다.
```csharp
// 키워드 검색
public Item this[string name]
{
    get { return _dict[name]; }
}

bag["Potion"]

// 조건 검색
public Item this[int minLevel, int maxLevel]
{
    get { return FindItemByLevel(minLevel, maxLevel); }
}

bag[10, 20]

// 계산 로직
public int this[float percent]
{
    get { return (int)(_max * percent); }
}

hp[0.5f]
```
- 인덱서 호출은 전부 대괄호 `[]`로 접근해야 합니다.

 
## 실제 사용
- 인덱서는 여러 개의 객체를 담아 배열처럼 보이게 하는 UI 문법이기 때문에 배열이 사용될 수 있는 곳에 대부분 사용할 수 있습니다.
- 인벤토리 & 아이템 컨테이너 / 설정 관리 등
<br></br>


# 과제 3(심화/선택사항). 반복기 (Iterator)
- 특정 동작이나 행위를 반복할 때 사용합니다.
- `IEnumerable<>`, `IEnumerator<>`로 구성된 제네릭 인터페이스.

## 특징
- 순차적 접근
  - 이터레이터는 컬렉션 내 요소에 **순서대로 하나씩** 접근할 수 있습니다.
- 생태 관리
  - `IEnumerator` 인터페이스는 `Current, MoveNext, Reset` 메서드를 통해 **현재 요소의 상태를 유지**, 다음 요소로 이동하거나 시작점으로 되돌릴 수 있습니다.
- 지연 실행
  - `yield return`을 이용해 필요한 순간 데이터를 반환, **모든 요소를 미리 메모리에 로드하지 않고 필요할 때마다 생성**하여 반환합니다. 메모리 사용량을 최소화할 수 있습니다.
- 컬렉션의 캡슐화
  - 이터레이터는 컬렉션의 내부 구조를 노출하지 않고 데이터를 순차적으로 접근할 수 있습니다. 데이터가 배열 혹은 리스튼 상관없이 외보에서 이터레이터를 통해 접근할 수 있습니다.
- 반복 가능한 구조
  - `IEnumerable` 인터페이스를 통해 다양한 데이터 구조가 **foreach 반복문과 같은 구문으로 접근 가능**해집니다. 이로 인해 가독성과 일관성을 높일 수 있습니다.

## 실제 사용
- 파일 검색 / 로그 분석
- 게임 맵 / 타일 순회
- AI / 시뮬레이션  
등이 있습니다.