# TIL (Today I Learned) – 알고리즘

**날짜: 2026.01.02 금요일**


## 알고리즘
- 문제를 해결하기 위한 과정을 논리적 절차에 따라 구성한 일련의 단계
- 입력 값에 대해 튜링머신이 정지하게 하는 명령
  **튜링머신 : 수학적 모형의 일종으로, 특수한 테이프를 기반으로 작동하는 기계**

#### 알고리즘의 설계 과정
- <mark class="hltr-idea">문제 이해</mark> → <mark class="hltr-idea">예시와 테스트 케이스 작성</mark> → <mark class="hltr-idea">알고리즘 설계</mark> → <mark class="hltr-idea">알고리즘 구현 및 검증</mark> → <mark class="hltr-idea">알고리즘 분석과 개선</mark> 

> 문제의 이해
- 문제의 요구 사항을 분석하고 입력과 출력의 형식을 파악

> 예시와 테스트 케이스 작성
- 몇 가지 예시를 들어 입력 값에 따라 어떤 결과를 도출해야 하는지 파악
- 이를 테스트 케이스를 작성했다고 표현

> 알고리즘 설계
- 문제 해결을 위한 본인만의 알고리즘 구상 단계
- 최우선 목표는 <mark class="hltr-idea">정확도</mark>, 그 다음 고려 사항은 <mark class="hltr-idea">알고리즘의 효율성, 즉 Big-O 값</mark>
- 바로 코드를 치는 것보다 <mark class="hltr-idea">의사코드(pseudo-code)</mark> 혹은 흐름도를 먼저 그리는 것을 추천
```csharp
while(b가 100보다 작다면?)
{
  i를 1 올린다;
  if(배열의 i번째 요소가 10보다 크다면?)
    {
      b를 제곱 시킨다;
      n도 올려서 총 b가 몇번 제곱되었는지 측정;
    }
}
```
- 의사코드는 <mark class="hltr-lb">수도코드</mark> 혹은 <mark class="hltr-lb">슈도코드</mark> 라고도 한다. <mark class="hltr-lb">가짜의</mark>, <mark class="hltr-lb">유사한</mark>을 의미하는 접두어 pseudo-와 코드를 의미하는 code에서 유래한 단어이다.

> 알고리즘 구현 및 검증
- 의사코드나 흐름도에 따라 코드 작성
- 제작 후 사전에 만들어 둔 테스트 케이스를 통해 검증
- 해당 단계에선 개선하지 말 것
	- 최적화와 관계된 알고리즘 중 <mark class="hltr-idea">브루트 포스</mark>가 있다.
	- 암호 해독법으로 <mark class="hltr-idea">키 전수조사</mark> 또는 <mark class="hltr-idea">무차별 대입</mark>을 통해 모든 문자열을 하나씩 대입해 보는 방식으로 암호를 해독하는 방법으로 <mark class="hltr-lb">계산 노가다</mark>의 학술적 개념이다.
	- 즉, 알고리즘 구현 및 검증 단계에서 굳이 개선하려고 하지 말고 필요에 따라 최적화 등이 불 필요할 수도 있다.

> 알고리즘 분석과 개선
- 정상 작동한다면 성능 분석을 통해 최적화, 개선의 여지 확인

> 핵심 요소
- 입력 (Input)
	- <mark class="hltr-main">문제를 풀기 위한 자료</mark>
	- <mark class="hltr-idea">입력을 기준으로 동작하는가</mark>를 명확하게 정의
- 출력 (Output)
	- <mark class="hltr-main">문제를 해결한 결과</mark>
	- 입력에 대응하는 <mark class="hltr-idea">출력이 명확히 존재</mark>
- 명확성 (Definiteness)
	- <mark class="hltr-main">명확하게 정의되어야 한다</mark>
	- 각 단계가 수행해야 할 작업은 <mark class="hltr-idea">구체적이며 애매하지 않아야 한다</mark>
- 유한성 (Finiteness)
	- <mark class="hltr-main">반드시 끝나야 한다</mark>
	- 복잡한 알고리즘이라도 <mark class="hltr-idea">유한한 단계를 거쳐 종료</mark>
- 효과성 (Effectiveness)
	- <mark class="hltr-main">실행 가능한 절차</mark>
	- 프로그램으로 구현했을 때 실행 가능한 수준의 <mark class="hltr-idea">구체성</mark>이 확보되어야 한다

<mark class="hltr-main">알고리즘을 설계할 때는 알고리즘의 <mark class="hltr-lb">정확성</mark>과 이를 검증할 <mark class="hltr-lb">검증 방법</mark>을 최우선으로 고려</mark>

#### 재귀 함수를 통해 알고리즘 구현
```csharp
namespace ConsoleApp1;  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        Factorial(5);  
    }  
    // 일반 함수  
    static void PrintStep(int startNumber, int stopNumber)  
    {  
        for (int i = startNumber; i <= stopNumber; i++)  
        {  
            Console.WriteLine(i);  
        }  
    }  
  
    static int Factorial(int number)  
    {  
        // 입력 : 5 (= 5!)        // 5 * 4 * 3 * 2 * 1 = 120  
        // 기저조건  
        if (number <= 1) return 1;  
          
          
        // 재귀조건  
        return number * Factorial(number - 1);  
    }  
          
// 재귀 함수  
    // => 함수가 자기 자신을 호출하도록 하는 프로그래밍 기법  
    // => 기저 조건 : 재귀 호출을 멈추는 조건  
    // => 재귀 조건 : 자기 자신을 호출하는 부분  
    // => 재귀로 가능한 것은 반복문으로도 해결할 수 있다.  
    // => 반복문으로 해결하는 문제를 모두 재귀로 해결할 수는 없다.  
    // => 분할 정복법의 핵심적인 역활을 함  
    static void PrintStep2(int startNumber, int stopNumber)  
    {  
        if (startNumber > stopNumber)  
        {  
            return;  
        }  
        Console.WriteLine(startNumber);  
        PrintStep2(startNumber + 1, stopNumber);  
    }  
}
```

### 정렬 알고리즘
- 특정 배열이나 콜렉션을 넘겨주고, 해당 컨테이너를 오름차순이나 내림차순으로 정렬시킬 때 필요
- 정렬 별로 Big-O 값을 가지고, 이는 알고리즘의 평균적인 성능을 나타냄
- [정렬 알고리즘 미리보기](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

###### 버블 정렬 (bubble Sort)
- BigO : O(n^2)
- 인접한 두 원소를 비교하여 순서가 잘못되어 있다면 서로 교환하는 과정을 반복하여 정렬
```csharp
static void BubbleSrot(List<int> list)  
{  
    bool isSorted = false;  
      
    for (int i = 0; i < list.Count - 1; i++)  
    {  
        isSorted = false;  
          
        for (int j = 0; j < list.Count - i - 1; j++)  
        {  
            if (list[j] > list[j + 1])  
            {  
                SwapInList(list, j, j + 1);  
                isSorted = true;  
            }  
        }  
        if (!isSorted) return;  
    }  
}
```

###### 선택 정렬 (Selection Sort)
- BigO : O(n^2)
- 주어진 리스트의 최솟값을 선택하여 정렬되지 않은 부분과 정렬된 부분을 나누고, 정렬되지 않은 부분에서 최솟값을 선택하여 정렬된 부분에 추가하는 과정을 반복
```csharp
static void SelectionSort(List<int> list)  
{  
    for (int i = 0; i < list.Count - 1; i++)  
    {  
        foreach (int l in list)  
        {  
            Console.Write($"[{l}]");  
        }  
        int minIndex = i;  
  
        for (int j = i + 1; j < list.Count; j++)  
        {  
            if (list[j] < list[minIndex])  
            {  
                minIndex = j;  
            }  
        }  
        if (minIndex != i)  
        {  
            SwapInList(list, i, minIndex);  
        }  
    }
}
```

###### 삽입 정렬 (Insertion Sort)
- BigO : O(n^2)
- 리스트를 정렬된 부분과 정렬되지 않은 부분으로 나눈 후, 정렬되지 않은 부분의 원소를 정렬된 부분의 적절한 위치에 삽입하는 과정을 반복하여 정렬
```csharp
static void InsertionSort(List<int> list)  
{  
    for (int i = 1; i < list.Count; i++)  
    {  
        int target = list[i];  // 현재 값  
        int j = i - 1;  
  
        while (j >= 0 && list[j] > target)
        // target보다 작은 값들을 한 칸씩 뒤로 밀기  
        {  
            list[j + 1] = list[j];  
            j--;  
        }  
        list[j + 1] = target;
        // target을 올바른 위치에 삽입  
    }  
}
```

###### 퀵 정렬 (Quick Srot)
- BigO : 평균 O(n log n), 최악 O(n^2)
- 분할 정복(Divide and Conquer) 기법을 사용하는 정렬 알고리즘으로, 리스트를 기준값을 중심으로 분할한 후 재귀적으로 정렬
```csharp
public static void QuickSort(int[] arr, int low, int high)
{
    if (low < high)
    {
        int pivotIndex = Partition(arr, low, high);

        QuickSort(arr, low, pivotIndex - 1);
        QuickSort(arr, pivotIndex + 1, high);
    }
}

private static int Partition(int[] arr, int low, int high)
{
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++)
    {
        if (arr[j] < pivot)
        {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    int temp2 = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp2;

    return i + 1;
}
```

###### 병합 정렬 (Merge Sort)
- BigO : O(n log n)
- 분할 정복(Divide and Conquer) 기법을 사용하는 정렬 알고리즘으로, 리스트를 반으로 나눈 후 재귀적으로 정렬한 다음, 정렬된 부분 리스트를 병합하여 최종적으로 정렬을 수행
```csharp
public static void MergeSort(int[] arr, int left, int right)
{
    if (left < right)
    {
        int mid = (left + right) / 2;

        MergeSort(arr, left, mid);
        MergeSort(arr, mid + 1, right);

        Merge(arr, left, mid, right);
    }
}

private static void Merge(int[] arr, int left, int mid, int right)
{
    int n1 = mid - left + 1;
    int n2 = right - mid;

    int[] leftArr = new int[n1];
    int[] rightArr = new int[n2];

    Array.Copy(arr, left, leftArr, 0, n1);
    Array.Copy(arr, mid + 1, rightArr, 0, n2);

    int i = 0, j = 0;
    int k = left;

    while (i < n1 && j < n2)
    {
        if (leftArr[i] <= rightArr[j])
        {
            arr[k] = leftArr[i];
            i++;
        }
        else
        {
            arr[k] = rightArr[j];
            j++;
        }
        k++;
    }

    while (i < n1)
    {
        arr[k] = leftArr[i];
        i++;
        k++;
    }

    while (j < n2)
    {
        arr[k] = rightArr[j];
        j++;
        k++;
    }
}
```
###### 힙 정렬 (Heap Sort)
- BigO : O(n log n)
- 힙(Heap) 자료 구조를 이용하여 정렬을 수행하는 알고리즘, 주어진 리스트를 최대 힙(Max Heap) 또는 최소 힙(Min Heap)으로 구성한 후, 힙에서 원소를 하나씩 꺼내 정렬된 순서로 배열
```csharp
public static void HeapSort(int[] arr)
{
	int n = arr.Length;

	for (int i = n / 2 - 1; i >= 0; i--)
		Heapify(arr, n, i);

	for (int i = n - 1; i > 0; i--)
	{
		int temp = arr[0];
		arr[0] = arr[i];
		arr[i] = temp;

		Heapify(arr, i, 0);
	}
}

private static void Heapify(int[] arr, int n, int i)
{
	int largest = i;
	int left = 2 * i + 1;
	int right = 2 * i + 2;

	if (left < n && arr[left] > arr[largest])
		largest = left;

	if (right < n && arr[right] > arr[largest])
		largest = right;

	if (largest != i)
	{
		int temp = arr[i];
		arr[i] = arr[largest];
		arr[largest] = temp;

		Heapify(arr, n, largest);
	}
}
```

###### **정렬에 사용한 SwapInList함수**
```csharp
static void SwapInList(List<int> list, int a, int b)  
{  
    int temp = list[a];  
    list[a] = list[b];  
    list[b] = temp;  
}
```

#### 기타 정렬 알고리즘
- 계수 정렬(Counting Sort), 셸 정렬(Shell Sort), 거품 정렬(Bogo Sort), 래딕스 정렬(Radix Sort) 등이 있다.
- 길찾기 모든 알고리즘을 외울 필요는 없지만, 높은 수준의 회사를 노린다면 위의 정렬 방법을 직접 구현하거나 최소 의사코드로 구현할 수 있어야 한다. 퀵소트, 삽입, 선택 정렬 세 가지는 실제로 유명 기업들에서 의사코드로 구현하라는 문제가 나온 적 있다.

#### 탐색 알고리즘
- 자료구조 내에서 찾고자 하는 데이터를 찾는 방식
- <mark class="hltr-idea">자료구조 : 그래프</mark>의 DFS, BFS가 탐색 알고리즘의 한 종류
###### 이진 탐색(BinarySearch) 구현
```csharp
static void Main(string[] args)  
{  
    List<int> list = new(100000);  
  
    for (int i = 1; i <= 100000; i++)  
    {  
        list.Add(i);  
        Console.WriteLine($"add : {i}");  
    }  
    int findValue = new Random().Next(0, list.Count);  
      
    BinarySearch(list, findValue);  
}  
  
static void BinarySearch(List<int> list, int target)  
{  
    int count = 0;  
    int start = 0;  
    int end = list.Count - 1;  
  
    while (start <= end)  
    {  
        count++;  
        int pivot = start + (end - start) / 2;  
  
        if (list[pivot] == target)  
        {  
            Console.WriteLine($"찾았음. count : {count}");  
            return;  
        }  
  
        if (list[pivot] < target) start = pivot + 1;  
        else end = pivot - 1;  
    }  
}
```

## 느낀 점
- 알고리즘이란 단어 자체는 친숙하지만, 막상 접하는 순간 겁을 먹었습니다.
- 하지만 알고리즘이 그 동안 배웠던 것들로 이루어진 것이며 입력 값을 가지고 목표로 도달하는 모든 과정이 알고리즘이라는 것을 알게 되었습니다.
- 물론 알고리즘의 종류도 많고, 구현 난이도가 쉬운 것도 어려운 것도 있지만 진입 장벽 자체는 낮아진 느낌이었습니다.