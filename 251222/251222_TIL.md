# TIL (Today I Learned) – C# 객체지향 프로그래밍 & 값 / 참조 타입

**날짜: 2025-12-22 월요일**

## 객체지향 프로그래밍(OOP)이란?
- 객체(Object) 들이 서로 상호작용하며 프로그램이 동작하는 방식
- 현실 세계 개념을 코드로 표현하는 인간 친화적 프로그래밍 패러다임
- C#은 클래스 기반 객체지향 언어
- 유니티 프로그래밍에서도 필수적으로 사용됨
<br></br>

## 객체지향 프로그래밍의 4대 특징

### 캡슐화 (Encapsulation)
- 객체는 데이터(필드) 와 동작(메서드) 를 함께 가진다
- 외부에서 불필요한 접근을 막기 위해 은닉성 제공
- C#에서는 접근 지정자 + 프로퍼티로 구현
```csharp
private int _playerID;

public int PlayerID
{
    get { return _playerID; }
    private set { _playerID = value; }
}
```

### 상속 (Inheritance)
- 부모 클래스의 필드와 메서드를 재사용
- 공통 기능을 부모에 정의하여 코드 중복 감소
- 자식 클래스는 자신만의 기능을 추가 가능
```csharp
public class Vehicle { }
public class Car : Vehicle { }
```

### 추상화 (Abstraction)
- 객체의 본질적인 속성과 기능만 표현
- 불필요한 세부 구현은 제거
- 프로그램에서 필요한 정보만 모델링

### 다형성 (Polymorphism)
- 같은 타입이 상황에 따라 다른 동작
- 부모 타입으로 자식 객체를 다룰 수 있음
- 상속과 오버라이딩의 핵심 개념
<br></br>

## SOLID 원칙 (객체지향 설계 원칙)

### 단일 책임 원칙 (SRP)
- 하나의 클래스는 하나의 책임만 가져야 한다

### 개방-폐쇄 원칙 (OCP)
- 기능 확장에는 열려 있고
- 기존 코드는 수정하지 않도록 설계

### 리스코프 치환 원칙 (LSP)
- 자식 객체는 언제든 부모 타입으로 대체 가능해야 한다
- 다형성의 전제 조건

### 인터페이스 분리 원칙 (ISP)
- 하나의 거대한 인터페이스보다
- 작고 목적에 맞는 인터페이스 여러 개가 낫다

### 의존 역전 원칙 (DIP)
- 구현 클래스가 아닌 추상 타입에 의존
- 변경에 유연한 구조 설계 가능
<br></br>

## 메모리 구조 이해

### 스택 영역 (Stack)
- 지역 변수, 매개변수 저장
- 후입선출(LIFO)
- 속도가 빠르고 자동 관리

### 힙 영역 (Heap)
- 클래스 인스턴스 저장
- GC(Garbage Collector)가 관리
- 동적 메모리 영역

### 데이터 영역
- static 변수, 전역 변수
- 프로그램 종료 시까지 유지

### 코드 영역
- 실행 가능한 코드 저장
- 프로그램 시작 시 메모리에 로드
<br></br>

## 값 타입과 참조 타입

### 값 타입 (Value Type)
- 값 자체가 복사
- 구조체(struct), int, float 등
- 주로 스택에 저장
- 구조체는 값 타입
```csharp
struct Point
{
    int x;
    int y;
}
```

### 참조 타입 (Reference Type)
- 주소(참조) 가 전달됨
- class, array, string 등
- 힙 영역에 저장
```csharp
class Player { }
```

### 클래스와 인스턴스
- 클래스는 설계도
- 인스턴스는 실제 객체
```csharp
Player player = new Player();
```
<br></br>

## 메서드에 인자를 전달할 때 동작 방식

### 값 타입을 전달할 경우
- 값이 복사됨
- 메서드 내부에서 변경해도 원본에 영향 ❌
```csharp
void ChangeValue(int x)
{
    x = 10;
}
```

### 참조 타입을 전달할 경우
- 참조(주소)가 복사됨
- 객체 내부 값 변경 시 원본에 영향 ⭕
- 참조 자체를 바꾸면 원본에는 영향 ❌
```csharp
void ChangePlayer(Player p)
{
    p.PlayerLevel = 10;
}
```
<br></br>

## 오늘의 정리
- 객체지향은 문법보다 설계 사고방식
- 캡슐화 + 프로퍼티는 C#의 핵심
- 값/참조 타입 차이는 버그 방지와 성능 최적화에 중요
- 면접, 유니티, 실무 전부에서 계속 쓰이는 개념


<br></br>
<br></br>
<br></br>
-------
<br></br>
<br></br>

# TIL (Today I Learned) – C# 객체지향 프로그래밍 & 값 / 참조 타입

**날짜: 2025-12-22 월요일**

## 구조체(struct) vs 클래스(class) 실전 기준
- 구조체는 값 타입(Value Type)
- 클래스는 참조 타입(Reference Type)
- 구조체는 데이터, 클래스는 객체 개념에 가깝다
<br></br>

## 구조체(struct)의 특징
- 값 타입(Value Type)
- 값 자체가 복사됨
- 주로 스택 영역에 저장
- GC(Garbage Collector) 부담이 적음
- 상속 불가 (인터페이스 구현은 가능)
- 크기가 작고 단순한 데이터에 적합
```csharp
struct Point
{
    public int X;
    public int Y;
}
```
<br></br>

## 클래스(class)의 특징
- 참조 타입(Reference Type)
- 객체의 주소(참조)를 공유
- 힙 영역에 저장
- GC 관리 대상
- 상속 및 다형성 사용 가능
- 상태와 동작을 가지는 객체 표현에 적합
```csharp
class Player
{
    public int Level;
}
```
<br></br>

## 메모리 관점에서의 차이

### 구조체
- 변수에 데이터 자체가 저장됨
- 메서드 인자로 전달 시 값이 복사됨
- 크기가 커질수록 복사 비용 증가

### 클래스
- 변수에는 참조(주소)만 저장됨
- 메서드 인자로 전달 시 참조만 복사됨
- 객체 크기와 상관없이 전달 비용 일정
<br></br>

## 언제 구조체를 사용해야 할까?
- 크기가 작고 단순한 데이터일 때
- 불변(immutable)에 가까운 값일 때
- 자주 생성되고 사라지는 데이터일 때
- 객체로서의 정체성이 필요 없을 때
```csharp
struct DamageInfo
{
    public int Value;
    public bool IsCritical;
}
```
- Unity의 `Vector3`, `Color`가 구조체인 이유
<br></br>

## 언제 클래스를 사용해야 할까?
- 상태가 지속적으로 변하는 경우
- 여러 곳에서 동일한 객체를 공유해야 할 때
- 상속, 다형성 등 객체지향 설계가 필요할 때
- 게임 오브젝트나 시스템 단위의 개념일 때
```csharp
class Enemy
{
    public int HP;

    public void TakeDamage(int damage)
    {
        HP -= damage;
    }
}
```
<br></br>

## 함수 인자로 전달할 때의 차이

### 구조체 전달
```csharp
void Move(Point p)
{
    p.X += 10;
}
```
- 메서드 내부 변경 사항이 원본에 반영되지 않음
- 값이 복사되었기 때문

### 클래스 전달
```csharp
void LevelUp(Player p)
{
    p.Level++;
}
```
- 메서드 내부 변경 사항이 원본 객체에 반영됨
- 같은 객체를 참조하고 있기 때문
<br></br>

## 실무에서 자주 발생하는 실수
- 구조체를 클래스처럼 크게 설계하는 경우
- 잦은 구조체 복사로 인한 성능 저하
- 클래스인데 값처럼 취급해 의도치 않은 상태 변경 발생

## 면접용 한 줄 정리
- 상태와 행동을 가지는 대상 → 클래스
- 단순 데이터 묶음 → 구조체
- 크고 복잡하면 클래스, 작고 단순하면 구조체

## Unity 기준 정리
- 좌표, 방향, 색상 → 구조체 (`Vector3`, `Color`)
- 플레이어, 몬스터, 시스템 → 클래스
- 로직과 상태를 가지면 클래스
- 값 전달이 목적이면 구조체
<br></br>

## 오늘의 정리
- 구조체는 성능과 데이터 중심
- 클래스는 설계와 객체 중심
- “이게 객체인가 값인가?” 를 먼저 판단하는 것이 중요