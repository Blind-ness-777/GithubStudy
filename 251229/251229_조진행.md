# 과제 1. 자판기
```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.Clear();

        VendingMachine machine = new VendingMachine();

        int value = 0;

        while (true)
        {
            if (!int.TryParse(Console.ReadLine(), out value))
            {
                Console.WriteLine("숫자를 입력해주세요.");
                continue;
            }
            
            if (value <= 0)
            {
                Console.WriteLine("1 이상의 숫자를 입력해주세요.");
                continue;
            }

            break;
        }
        
        for (int i = 0; i < value; i++)
        {
            machine.AddMilk(new Milk());
        }
    }
}

public class Milk
{
    public int ExpirationDate { get; private set; }
    
    public Milk()
    {
        ExpirationDate = 7;
    }
}

public class VendingMachine
{
    Queue<Milk> milkQueue = new Queue<Milk>();

    public void AddMilk(Milk milk)
    {
        milkQueue.Enqueue(milk);
        Console.WriteLine("우유가 보충되었습니다.");
        Console.WriteLine($"남은 우유 : {milkQueue.Count}");
    }

    public void RemoveMilk()
    {
        if (milkQueue.Count <= 0)
        {
            Console.WriteLine("자판기에 우유가 없습니다.");
            return;
        }
        
        Milk milk = milkQueue.Dequeue();
        
        Console.WriteLine($"꺼낸 우유의 유통기한 : {milk.ExpirationDate}");
        
        Console.WriteLine($"자판기에 우유가 {milkQueue.Count}개 남아 있습니다.");
    }
}
```
<br></br>

# 과제 2. 카드 덱
```csharp
class Program
{
    static void Main(string[] args)
    {
        Console.Clear();
    }
}

public enum Shape
{
    Spade,
    Heart,
    Clover,
    Diamond
};

public class Card
{
    public Shape CardShape { get; private set; }
    public int Number { get; private set; }
    
    public Card(Shape shape, int value)
    {
        CardShape = shape;
        Number = value;
    }
}

public class CardDeck
{
    private Stack<Card> unusedCards = new Stack<Card>();
    private Stack<Card> usedCards = new Stack<Card>();

    public CardDeck()
    {
        Shape[] shapes = new Shape[]
        {
            Shape.Spade,
            Shape.Heart,
            Shape.Clover,
            Shape.Diamond
        };
        
        foreach (Shape shape in shapes)
        {
            for (int number = 1; number <= 13; number++)
            {
                unusedCards.Push(new Card(shape, number));
            }
        }
    }

    public Card ShowTopCard()
    {
        return unusedCards.Peek();
    }

    public Card DrawCard()
    {
        Card card = unusedCards.Pop();
        usedCards.Push(card);
        return card;
    }
}
```
- `CardDeck`을 `Stack` 자료 구조형으로 작성한 이유는, 카드 덱의 동작이 맨 위 카드만을 기준으로 꺼내고 쌓는 `후입선출(LIFO)` 구조이기 때문입니다. 따라서 `Push`, `Pop`, `Peek` 연산이 카드 덱의 규칙과 1:1로 대응되어 구현이 직관적이기 때문입니다.

<br></br>

# 과제 3(심화/선택사항) Dequeue

## Deque 조사 및 설계 요약
### Deque란?
- Deque(Double-ended Queue)는 양쪽 끝(front/back)에서 삽입과 삭제가 가능한 자료구조이다.

### 왜 Deque가 필요한가?
- Deque는 Queue와 Stack의 기능을 하나의 구조로 통합한 자료구조로,
  - 앞/뒤 어느 쪽에서도 삽입·삭제가 가능하여
  - 캐시, 작업 스케줄러, BFS/DFS, Undo/Redo 시스템 등 다양한 시스템에서 사용된다.

### 배열로 구현 시
- 내부 배열을 원형(Circular Buffer) 구조로 사용
- front / rear 인덱스로 앞/뒤 위치를 추적
- 배열이 가득 차면 2배 크기로 재할당

### 구현 전략 개요
| 메서드 | 동작 개요 |
|---|---|
| PushFront | front를 한 칸 앞으로 이동 후 해당 위치에 저장 |
| PushBack | rear 위치에 저장 후 rear 이동 |
| PopFront | front 위치 데이터 반환 후 front 이동 |
| PopBack | rear을 한 칸 뒤로 이동 후 해당 위치 데이터 반환 |
| Clear | count=0, front/rear 초기화 |

### 배열 리사이즈
- count == capacity 시 2배 크기의 새 배열 생성
- 기존 데이터를 front부터 순서대로 복사
- front=0, rear=count로 재정렬