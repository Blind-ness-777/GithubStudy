**날짜: 2026.01.15 목요일**

## 오브젝트(Object)
- 주로 게임에서 아이템을 지칭하거나 맵 상에서 상호작용할 수 있는 요소를 지칭하는 용어로 쓰인다.
- 그러나 개발자에게 오브젝트란 더 넓은 범위에 속하는 개념이다.
- 오브젝트란 특정 공간에 존재하는 모든 것이다.
- 예를 들어 방 한가운데, 책상이 있고 그 위에 여러가지 물건들이 있다면?
- 방이라는 존재부터 시작해 책상을 비롯해 책상 위의 여러가지 물건들까지 전부 오브젝트라고 할 수 있고, 눈에 보이지 않는 공기 등 형체가 없지만 오브젝트라고 할 수 있다.
- 즉, <mark class="hltr-lb">특정 물체에만 적용되는 개념이 아니다.</mark>

### 컴포넌트(Component)
- 모든 물체는 <mark class="hltr-idea">'기능과 형태'</mark>를 가진다.
- 즉, 물체라는 것은 <mark class="hltr-idea">'자신에게 주어진 기능과 성질'</mark>을 간직하고 있는 <mark class="hltr-lb">'매개체'</mark>라고 할 수 있다.
- 유니티의 가상 공간에서 오브젝트에 기능과 성질을 부여하기 위해 오브젝트에 기능과 성질을 부여하는 <mark class="hltr-lb">'컴포넌트'</mark>라는 개념을 사용한다.
- 여러 오브젝트가 동일한 컴포넌트를 담을 수 있다.
- 오브젝트 = `컴포넌트를 담을 수 있는 상자`

#### Transform
- 게임 오브젝트는 `Transform`이라는 컴포넌트를 기본적으로 가지고 있다.
> Transform Component
>- 위치, 회전각, 크기에 대한 3축(x, y, z)의 정보를 가지고 있다.

#### Scene, Scene Management
- IDE에서 새로운 .cs 파일을 만드는 것처럼 굳이 새로운 프로젝트를 만들지 않고, Scene을 추가하는 방법으로 새로운 프로젝트를 만든 것처럼 이용 가능하다.
- 같은 프로젝트 내에 여러 Scene이 존재할 경우 서로를 불러와 사용하거나 엮을 수 있고, Build Settings를 이용해 연계시킬 수도 있다.
- `Build Settings` = 프로젝트를 빌드할 때 사용할 Scene만 선별하는 기능이다. 빌드에 포함되지 않은 Scene은 게임 실행 파일에 들어가지 않는다.
- Build Settings에 등록된 Scene의 순서. 즉, 인덱스 주소를 이용해 <mark class="hltr-main">SceneManager.LoadScene</mark>를 통해 Scene을 전환할 수 있다.

```csharp
using System;  
using System.Collections;  
using System.Collections.Generic;  
using UnityEngine;  
using UnityEngine.SceneManagement;  
  
public class SceneChanger : MonoBehaviour  
{  
    public void Update()  
    {  
        if (Input.GetKeyDown(KeyCode.Space))
        {  
            // 씬 전환
            // 인덱스 값과 씬 제목으로 변경 가능
            // 씬 제목의 경우 오타 등의 문제로 강사님은 인덱스를 추천
            // 문자열 처리는 당장쓰고 말 것들 위주로 사용
            // Build Settings에 등록된 순서대로 0,1,2… 인덱스가 부여된다.
            SceneManager.LoadScene((int)SceneName.Today);  
            SceneManager.LoadScene("260115");  
        }  
    }}  
  
// 열거형을 이용해 인덱스에 별명을 지어줄 수 있다.  
public enum SceneName  
{  
    SampleScene, Today  
}
```

#### 애트리뷰트(Attribute)
- 애트리뷰트(Attribute)는 코드에 메타 정보를 부여하여 컴파일러, 런타임, 엔진, 툴이 해당 코드를 어떻게 취급해야 하는지 알려주는 표식이다.
- 대표적으로 Inspector 표시 조절을 할 수 있기에 흔히 `Attribute = Inspector 표시 조절기`라는 오해가 생기기도 한다.
- 또한 애트리뷰트를 사용할 땐 대괄호 `[]`를 사용하고 적용할 코드를 한 줄 아래에 적거나 한 칸 띄어 작성하면 된다.

##### SerializeField
- 해당 필드를 Unity의 <mark class="hltr-lb">‘저장 대상 데이터’</mark>로 등록하여, 씬/프리팹 파일에 저장하고 Inspector에서 수정 가능하게 만드는 애트리뷰트이다.
- 프로퍼티의 경우 [field:SerializeField]로 애트리뷰트를 사용할 수 있는데 이 때, <mark class="hltr-lb">field:</mark>는 프로퍼티 내부에 자동 생성되는 <mark class="hltr-lb">‘백킹 필드(실제 저장 변수)’</mark>를 직접 가리키기 위한 C# 애트리뷰트 타겟 지정자이다.

##### Header
- Inspector 기준, 에디터 표시된 항목들의 그룹 명을 지정할 수 있다.

##### Tooltip
- Inspector 기준, 선택한 항목이 어떠한 역할을 하는지 설명을 적어 에디터에서 표시되게 할 수 있다.

##### Range
- 에디터에서 값을 수정할 때, 그 값을 직접 입력하거나 마우스로 조절하는 형태라면 Range를 통해 범위를 지정하고, 그 범위만큼 조절할 수 있는 슬라이더가 생긴다.

##### TextArea
- Inspector 기준, 아래 예시처럼 설명란을 만들어 주고, 최소 몇 줄이 노출될 건지와 사이드 슬라이드 없이 최대 몇 줄까지 표시할 건지를 정할 수 있다.

```csharp
using System.Collections;  
using System.Collections.Generic;  
using UnityEngine;  
  
public class CubeController : MonoBehaviour  
{  
    // private 작성 시 유니티 Inspector에 뜨지 않음  
    // 은닉성을 지키며 유니티에 보여주는 방식을 애트리뷰트(Attribute)라고 한다.  
    // 애트리뷰트는 단순 은닉성을 지키는 수단이 아니라 추가적으로 여러 기능도 제공한다.  
    // [SerializeField]라는 애트리뷰트가 은닉성을 지키며 유니티에 보여주는 기능을 가진 것이다  
    [Header("캐릭터 기본 능력치")]  
    public string Name;  
    [SerializeField] private int _health;  
    [field:SerializeField] public int Mana { get; set; }  
    [SerializeField][Range(0, 50)] private float _speed;  
      
    [Space(20)]
    
    [Header("공격대상 설정")]  
    [Tooltip("추적 대상 오브젝트")]   
	public GameObject target;  
      
    [TextArea(4, 15)]  
    public string Description;  
}
```

### 프리팹
- 일종의 `설계도`
- 여러 오브젝트를 배치하고, 이를 대량 생산해야 할 경우 설계도를 미리 작성해 놓으면 편하다.
- 프리팹은 설계도, 인스턴스는 실제로 생산된 객체.

#### 오브젝트의 상속
- 유니티에서는 오브젝트의 하위 객체의 오브젝트를 추가하는 <mark class="hltr-lb">'상속'</mark>의 개념으로 구현한다.
- 하위 객체로 상속된 오브젝트는 자신의 위치 정보 <mark class="hltr-main">local Space</mark>와 전체 공간에서의 위치 정보 <mark class="hltr-main">world Space</mark>를 동시에 가지기 때문에 그룹화 된 오브젝트의 동작 제어가 간편하다.

 - 하지만 상속된 깊이와 단계가 깊어질 수록 여러 문제가 발생할 수 있다.
 1. 복잡도 증가
	 - 상속 관계가 깊을 수록, 하위 객체와 상위 객체들간의 접근성이 나빠진다.
	 - 최하위 객체가 상위 객체들에 접근하기 위해 코드적으로 많은 과정을 동반해야 한다.
	 - 코드의 가동성을 떨어뜨리고 상 하위 객체간의 의존성이 증가하는 결과를 초래한다.
 2. 성능 저하
	 - 상속 관계가 깊을 수록 하위 오브젝트의 데이터를 얻기 위해 각 오브젝트를 순회하는 시간이 길어진다.
 3. 메모리 사용량 증가
	 - 하위 객체는 <mark class="hltr-lb">상위 객체들의 정보</mark>를 함께 가지게 된다.
	 - 상속 관계가 깊어질 수록 하위 객체가 가져야 할 정보량과 메모리 사용량이 증가한다.

#### 오브젝트의 컴포넌트 참조하기
- 유니티 엔진이 지원하는 메서드 중 하나로, 특정 오브젝트가 가진 컴포넌트를 참조할 수 있도록 한다.

```csharp
// 해당 GameObject에 연결된 타입 T의 컴포넌트를 반환
// 컴포넌트가 여러 개 있다면, 첫 번째 발견된 컴포넌트를 반환
// 해당 타입의 컴포넌트가 없으면 null을 반환
GameObject.GetComponent<T>();
// 해당 GameObject에 연결된 모든 타입 T의 컴포넌트들을 배열로 반환
// 해당 타입의 컴포넌트가 없으면 빈 배열을 반환
GameObject.GetComponents<T>();
// 해당 GameObject와 그 자식들을 순회하며 타입 T의 첫 번째 컴포넌트를 반환
// 컴포넌트가 없으면 null을 반환
GameObject.GetComponentInChildren<T>();
// 해당 GameObject와 그 자식들을 순회하며 타입 T의 모든 컴포넌트들을 배열로 반환 // 해당 타입의 컴포넌트가 없으면 빈 배열을 반환
GameObject.GetComponentsInChildren<T>();
// 해당 GameObject와 그 부모들을 순회하며 타입 T의 첫 번째 컴포넌트를 반환
// 만약 그러한 컴포넌트가 없으면 null을 반환
GameObject.GetComponentInParent<T>();
// 해당 GameObject와 그 부모들을 순회하며 타입 T의 모든 컴포넌트들을 배열로 반환
// 해당 타입의 컴포넌트가 없으면 빈 배열을 반환
GameObject.GetComponentsInParent<T>();
```

### 생성과 파괴
- 규모가 증가할 수록 게임에서 다루는 오브젝트의 종류가 많아지고, 모든 경우의 수를 생각해 미리 오브젝트를 추가하는 건 불필요한 자원을 낭비하는 것이다.
- 게임 구동 중 오브젝트를 생성하고 파괴해야 한다.

```csharp
// 오브젝트 생성 함수
// 게임 오브젝트 타입을 매개변수로 입력
Instantiate(GameObject Object);

// 오브젝트 파괴 함수
// 게임 오브젝트 타입을 매개변수로 입력
Destroy(GameObject Object);
```

1. Instantiate
- 오브젝트를 <mark class="hltr-idea">동적</mark>으로 생성할 때 사용.
- 다양한 매개변수로 생성될 당시에 옵션을 제어.

1. Destroy
- 오브젝트를 <mark class="hltr-idea">동적</mark>으로 파괴할 때 사용.
- 대상 뒤로 시간에 해당하는 매개변수를 넣으면 지정 시간이 흐른 뒤 오브젝트 파괴.

```csharp
Destroy(GameObject Object, Time)
```

#### 사용 예시
- 컴포넌트부터 애트리뷰트, 프리팹 등을 전부 사용하여 헬리콥터를 구현, 총알이 발사되게 만들어 보았다.

```csharp
public class BulletController : MonoBehaviour  
{  
    [SerializeField] [Range(0, 20)] private float _moveSpeed;  
  
    private void Start()  
    {  
        Destroy(gameObject, 2f);  
    }  
    
    private void Update()  
    {  
        MoveForward();  
    }  
    
    private void MoveForward()  
    {  
        transform.Translate(transform.forward * (_moveSpeed * Time.deltaTime));  
    }  
}


public class HeliController : MonoBehaviour  
{
    [SerializeField] private GameObject _bulletPrefab;  
    [SerializeField] private Transform _muzzle;  
    
    private void Update()  
    {  
        if (Input.GetKey(KeyCode.Alpha1))  
        {  
            Fire();  
        }  
    }
    
    private void Fire()  
    {  
        Debug.Log("발사");  
        Instantiate(_bulletPrefab, _muzzle.position, _muzzle.rotation);  
    }
}
```


## 느낀 점
- 아직까지는 크게 어려움이 없는 것 같습니다.
- 일단 코드만 보고 Wirte 등으로 간접적으로 출력된 것만 보다가 직접 구현되고 동작하는 걸 보니 훨씬 재미있고, 이해도 잘 되는 것 같습니다. 앞으로 기대가 됩니다.