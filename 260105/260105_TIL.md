# TIL (Today I Learned) – 알고리즘 2

**날짜: 2026.01.05 월요일**

#### Sort
- 파티션 크기가 16개 요소보다 작거나 같은 경우 삽입 정렬 알고리즘 사용
- 파티션 수사 2 log n을 초과하는 경우 여기서 n은 입력 배열 범위이며, 힙소트 알고리즘 사용
- 그렇지 않으면 빠른 정렬 알고리즘을 사용
- Sort는 복합적인 여러 정렬 알고리즘이 섞인 상태

###### 퀵 정렬 (Quick Srot)
- BigO : 평균 O(n log n), 최악 O(n^2)
- <mark class="hltr-main">분할 정복(Divide and Conquer)</mark> 기법을 사용하는 정렬 알고리즘으로, 리스트를 기준값을 중심으로 <mark class="hltr-lb">분할</mark>한 후 <mark class="hltr-idea">재귀적</mark>으로 정렬
- <mark class="hltr-lb">pivot</mark> = 기준점
```csharp
static void QuickSort(List<int> list, int left, int right)  
{  
    if (left >= right) return;  
    
    int pivot = Partition(list, left, right);  
      
    QuickSort(list, left, pivot - 1);  
    QuickSort(list, pivot + 1, right);  
      
}  
  
static int Partition(List<int> list, int left, int right)  
{  
    int pivot = list[right];  
    int i = left - 1;  
      
    // 리스트 내부에서 pivot보다 작은 값들은 왼쪽으로.  
    for (int j = left; j < right; j++)  
    {  
        if (list[j] < pivot)  
        {  
            i++;  
            Swap(list, i, j);  
        }  
    }    // pivot을 작은 값 바로 다음 영역으로 이동시키고 고정.  
    int pivotIndex = i + 1;  
    Swap(list, pivotIndex, right);  
      
    return pivotIndex;  
}
```

###### 인트로 정렬(Intro Sort)
- 퀵 정렬로 시작한 다음 재귀 깊이가 정렬 대상 요소의 수의 레벨(로그)을 초과할 때 힙 정렬로 전환하며, 요소들의 수가 특정 임계치 미만일 때 삽입 정렬로 전환
- 명령어 Sort와 같은 조건.

###### 병합 정렬 (Merge Sort)
- BigO : O(n log n)
- <mark class="hltr-main">분할 정복(Divide and Conquer)</mark> 기법을 사용하는 정렬 알고리즘으로, 리스트를 반으로 나눈 후 <mark class="hltr-idea">재귀적</mark>으로 정렬한 다음, 정렬된 부분 리스트를 병합하여 최종적으로 정렬을 수행
- 병합 정렬은 더 이상 나눌 수 없을 때까지 나눈 후, 그것들을 비교하며 정렬하여 합친다
- C#에선 배열이 계속 생성된다는 단점이 존재. 사용에 주의 필요
```csharp
static void MergeSort(List<int> list, int left, int right)  
{  
    if (left >= right) return;  
    int center = (left + right) / 2;  
      
    MergeSort(list, left, center);
    MergeSort(list, center + 1, right);
      
    Merge(list, left, center, right);
}  
  
static void Merge(List<int> list, int left, int center, int right)
{
    // 임시 배열의 크기 = 현재 병합하는 범위의 길이
    int[] temp = new int[right - left + 1];
    
    int leftIndex = left;
    int rightIndex = center + 1;
    int tempIndex = 0;      // temp에서 사용할 인덱스
    
    // 두 범위에서 남아있는 동안 계속 비교하고, 작은 값을 temp로 이동
    while (leftIndex <= center && rightIndex <= right)
    {
        // 불안정 정렬 [2a][1][2b][3] => [1][2b][2a][3]
        // 안정 정렬 [2a][1][2b][3] => [1][2a][2b][3]
        if (list[leftIndex] <= list[rightIndex]) // 왼쪽을 우선시 함
        {
            temp[tempIndex] = list[leftIndex];
            leftIndex++;
        }
        else
        {
            temp[tempIndex] = list[rightIndex];
            rightIndex++;
        }
		
        tempIndex++;
    }
    
    // 왼쪽 범위에 남은 값이 있다면? => 그대로 temp로.
    while (leftIndex <= center)
    {
        temp[tempIndex] = list[leftIndex];
        leftIndex++;
        tempIndex++;
    }
    
    // 오른쪽 범위에 남은 값이 있다면 => 그대로 temp로.
    while (rightIndex <= right)
    {
        temp[tempIndex] = list[rightIndex];
        rightIndex++;
        tempIndex++;
    }
    
    // temp배열의 원소만 기존의 List에 덮어쓰기
    for (int t = 0; t < temp.Length; t++)
    {
        list[left + t] = temp[t];
    }
}
```

###### 정렬에 사용된 Swap 함수
```csharp
static void Swap(List<int> list, int a, int b)
{
    int temp = list[a];
    list[a] = list[b];
    list[b] = temp;
}
```

###### DFS
- 깊이 우선 탐색
```csharp
// 재귀적 DFS
public List<int> DFS(int start)
{
    List<int> path = new List<int>();
    bool[] visited = new bool[_vertextCount];
    
    InternalDFS(start, visited, path);
    
    return path;
}

public void InternalDFS(int current, bool[] visited, List<int> path)
{
    visited[current] = true;
    path.Add(current);
	
    for (int to = 0; to < _vertextCount; to++)
    {
        if (_matrix[current, to] && !visited[to])
        {
            InternalDFS(to, visited, path);
        }
    }
}

// StackDFS
public List<int> StackDFS(int start)
{
    List<int> path = new List<int>();
    Stack<int> stack = new Stack<int>();
    
    bool[] visited = new bool[_vertextCount];
    visited[start] = true;
    
    stack.Push(start);
    
    while (stack.Count > 0)
    {
        int current = stack.Pop();
        path.Add(current);
        
        for (int to = 0; to < _vertextCount; to++)
        {
            if (_matrix[current, to] && !visited[to])
            {
                visited[to] = true;
                stack.Push(to);
            }
        }
    }
    
    return path;
}
```

###### BFS
- 너비 우선 탐색
```csharp
public List<int> BFS(int start)
{
    List<int> path = new List<int>();
    Queue<int> queue = new Queue<int>();
    
    bool[] visited = new bool[_vertextCount];
    visited[start] = true;
    
    queue.Enqueue(start);
	
    while (queue.Count > 0)
    {
        int current = queue.Dequeue();
        path.Add(current);
	    
        for (int to = 0; to < _vertextCount; to++)
        {
            if (_matrix[current, to] && !visited[to])
            {
                visited[to] = true;
                queue.Enqueue(to);
            }
        }
    }
    
    return path;
}
```

###### 공통 사용 함수
```csharp
public class MatrixGraph
{
    private readonly bool[,] _matrix;
    
    private int _vertextCount;
    
    public MatrixGraph(int vertextCount)
    {
        _vertextCount = vertextCount;
        _matrix = new bool[vertextCount, vertextCount];
    }
    
    public void AddEdge(int from, int to)
    {
        _matrix[from, to] = true;
        _matrix[to, from] = true;
    }
    
    public bool HasEdge(int from, int to) => _matrix[from, to];
```

## 느낀 점
- 오늘은 유독 문법 이해가 안되는 날이었습니다.
- 전에는 이해하고 넘어갔던 부분도 복습하는 과정에서 왜 이렇게 작성했더라 헷갈리는 부분이 많은 날이었습니다.
- 조금 더 집중해서 공부할 필요가 있어 보입니다.